# -*- coding: utf-8 -*-
"""wordle_solver.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1efjgQOAO7oGHK2zv_CQB338jLB0i15fS
"""

from collections import Counter
import numpy as np

#Makes a dictionary where the values are the letters in the word and the keys are the place at which the letter occurs
def dictionary(word):
  dict= {1: word[0], 2: word[1], 3: word[2], 4: word[3], 5: word[4]}
  return dict

#Extract common letters between guess and word and correct places for letters if any. Also find the letters not resent in the word (i.e. the yellow, green and black letters in wordle).
def solver(guess_dict):
  global s
  for i in word_dict:
    count= 0
    for j in guess_dict:
      if word_dict[i] == guess_dict[j]:
        if i == j:
          place[i-1]= guess_dict[j]
        else:
          letter.append(guess_dict[j])

  flag= 0
  for i in guess_dict:
    for j in word_dict:
      if word_dict[j] == guess_dict[i]:
        flag= 1
    if flag != 1:
      letter_remove.append(guess_dict[i])
    flag= 0

  #Remove repeating letters from the lists
  for i in letter:
    if (i not in letter_new) and (i not in place):
      letter_new.append(i)
      for j in guess_dict:
        if i == guess_dict[j]:
          not_place[s]= j-1
          s= s+1
          print(i)
  if (i in letter_new) and (i in place):
    letter_new.remove(i)
  for i in letter_remove:
    if (i not in letter_remove_new):
      letter_remove_new.append(i)

  
  print(place, letter_new, letter_remove_new)

#Extract possible 5 letter words and all letters from text files
def get_words():

    word_file = open("words.txt","r")
    consonants_file = open("letters.txt","r")
    a = word_file.readlines()
    b = consonants_file.readlines()
    
    for i in a:
      list_words.append(i[:5])

    for i in b:
      consonants.append(i[:1])

    return(list_words, consonants)

#Remove words already guessed from the list
def remove_words(list_words):
  global no
  global index
  index= []
  no= 0
  count= 0
  flag = 0
  p= 0
  for i in place:
    if i != 0:
      no = no + 1
      index.append(count)
    count = count + 1

  list_words.remove(word_chosen)

  return(list_words, no, index)

#Decide next guess
def next_word(place, letter):
  global possibility
  global r
  possibility= []

  #Append through the list of words
  for i in list_words:
    flag1= 0
    flag2= 0
    flag3= 0
    flag4= 0
    #Check if the word satisfies the condition for letters in the correct places (green letters). If yes, append to possibilites.
    if ((any(place) == True) and (any(letter_new) == False)):
      for j in index:
        if i[j] == place[j]:
          flag1= flag1 + 1
        if flag1 == no:
          possibility.append(i)
    #Check if the word satisfies the condition for all the correct letters being present in the guess (yellow letters). If yes, append to possibilities.
    elif ((any(letter_new) == True) and (any(place) == False)):
      r= 0
      for j in letter_new:
        p= 0
        for k in i:
          if j == k:
            flag1= flag1 + 1
      if flag1 >= len(letter_new):
        possibility.append(i)
    #Check if the word satisfies both the conditions if both correct letters and places are present (yellow and green letters). If yes, append to possibilites.
    elif ((any(letter_new) == True) and (any(place) == True)):
      r= 0
      for j in index:
        if i[j] == place[j]:  
          flag1= flag1 + 1
        if flag1 == no:
          flag3= 1   
          flag1= 0
          flag2= 0
      for j in letter_new:
        p= 0
        for k in i:
          if j == k:
            flag1= flag1 + 1
      if flag1 >= len(letter_new):
        flag4= 1
      if ((flag3 == 1) and (flag4 == 1)):
        possibility.append(i)
    else:
      possibility.append(i)
  return(possibility)

#Choose the best option out of all the possible words
def choose_best(possibility, cost_dict, word_chosen):
  t= 0
  #Assign cost to words based on the letters they contain. Words containing letters occuring most frequently in the english language get lower costs. 
  for i in possibility:
    for j in i:
      #Words are penalized if they contain black letters
      if (j in letter_remove_new) :
        cost[t]= cost[t] + cost_dict[j] + 20
      else:
        cost[t]= cost[t] + cost_dict[j]

    repeated_letters= []
    WC = Counter(i)
    k = -1

    #Words are penalized if they have repeating letters
    for b in WC.values():
      k = k + 1
      if( b > 1 ):
        repeated_letters.append(b)
    cost[t]= cost[t] + 10*len(repeated_letters)

    #Words are penalized if the same letters appear in same places in muultiple guesses
    l=0
    counter= 0
    for j in i:
      if (j in letter_new) and (word_chosen[l] == j):
        counter= counter + 1
      l= l + 1
    cost[t]= cost[t] + counter*10

    t= t+1

  print(cost)
  cost1= cost.copy()
  cost1.sort()
  j= 0
  for i in cost:
    if i == cost1[0]:
      index1= j
    j= j+1
  global new_word
  new_word= possibility[index1]
  return(new_word)

word= input('Enter word ')

list_words = []
consonants = []
place= [0, 0, 0, 0, 0]
letter= []
letter_new= []
letter_remove= []
letter_remove_new= []
not_place= {0:[], 1:[], 2:[], 3:[]}
get_words()
global s, r
s= 0
r= 0
i= 0
print('#')
global word_chosen
word_chosen= 'raise'
print(word_chosen)
while word_chosen != word :
  print('*')
  guess = word_chosen

  guess_dict= dictionary(guess)
  word_dict= dictionary(word)

  solver(guess_dict)

  remove_words(list_words)

  next_word(place, letter_new)
  print(possibility)

  cost_dict= {'e':1, 'a':2, 'r':3, 'i':4, 'o':5, 't':6, 'n':7, 's':8, 'l':9, 'c':10 ,'u':11, 'd':12, 'p':13, 'm':14, 'h':15, 'g':16, 'b':17, 'f':18, 'y':19, 'w':20, 'k':21, 'v':22, 'x':23, 'z':24, 'j':25, 'q':26 }
  cost= []
  k= 0
  while k < len(possibility):
    cost.append(0)
    k= k+1

  choose_best(possibility, cost_dict, word_chosen)

  i= i+1
  word_chosen= new_word
  print(word_chosen)